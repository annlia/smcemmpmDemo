%%------------------------------------------------------------------------------------------%%
%% Demo code for Sequential Monte Carlo EM for multivariate probit models (SMCEMMPM)
%
%% Giusi Moffa and Jack Kuipers
%% University of Regensburg
%
%% Last modified: July 4, 2013
%
% Disclaimer: The code in this archive is not guaranteed to be optimised or free of bugs.
%        Please report any issues to the authors (giusi.moffa@ur.de, jack.kuipers@ur.de).
%%------------------------------------------------------------------------------------------%%

%%% See R knitr package
%%% http://yihui.name/knitr/demo/sweave/ 
%%% library(knitr)
%%% knit('knitSimPbit.Rnw')

\Sexpr{set_parent('knitSMCEMpbit.Rnw')}

\section{Simulated data analysis}

\subsubsection*{Loading libraries, sources and data}
<<loading, message=FALSE, cache=FALSE>>=
rm(list=ls(all.names=TRUE))
require(mvtnorm)
require(xtable)
pkgfolder <- "../smcPbitDemo/"
datafile <- paste0(pkgfolder,"simPbit8Data1k.RData") ### file with data to model 
### file with data to model
tosave <- TRUE
savefile <- "smcemPbitDemo.RData" ### file to save R workspace after processing 
### file to save R workspace after processing
### From within the working directory
source(paste0(pkgfolder, "resample.R"))
source(paste0(pkgfolder, "siginit.R"))
source(paste0(pkgfolder, "obseval.R"))
source(paste0(pkgfolder, "PbitEMstart.R"))
source(paste0(pkgfolder, "PbitEMloop.R"))
source(paste0(pkgfolder, "Mstep.R"))
source(paste0(pkgfolder, "smcEM.R"))
source(paste0(pkgfolder, "evallike.R"))
source(paste0(pkgfolder, "fisher.R"))
load(datafile) ### Read data
# source(paste0(pkgfolder,"buildsixcities.R"))
dep_prev()
@

\subsubsection*{Initializations}
<<initialize>>=
doProjection <- FALSE 
# projection to sigma_11=1 form is performed after M step - projection is not needed if constrained is TRUE
constrained <- TRUE 
# Maximisation is performed constrained - either in correlation form or with sigma_11=1 depending on useinvariance
useinvariance <- TRUE 
# Maximisation uses invariant Q tilde function instead of standard Q
fixM <- FALSE 
# keep the number of particles constant or not
nr <- 40
M <- 4000
refineM <- 1*M
startM <- 100
nc <- length(citygam[,1])
nobs <- length(citygam[1,])
nX <- length(cityX[[1]][1,])-1
avg.gam <- apply(citygam, 1, mean)  ### mean vector
cor.gam <- cor(t(citygam))			### correlation matrix
@

\subsubsection*{Compute starting point for the EM algorithm}
<<startingpoints>>=
pwsig <- siginit(avg.gam, cor.gam) ### covariance matrix pairwise estimate
updsig <- pwsig
obs <- c(t(citygam))
covmat <- matrix(0, nrow = nc*nobs, ncol=nX)
covmataux <- matrix(0, nrow= nobs, ncol = nX)
for(i in 1:nc){
  for(j in 1:nobs) covmataux[j,] <- cityX[[j]][i,2:(nX+1)]
	covmat[((i-1)*nobs+1):(i*nobs),] <- covmataux
}
indprobit <- glm(obs ~ covmat, family=binomial(link="probit"), na.action=na.pass)
indbe <- coef(indprobit) ### coefficients from fitting independent probit models
updbe <- indbe
@

\subsubsection*{Initialise variables for the results}
<<resultVars>>=
loglike <- rep(NA, nr)
regcoeff <- list()
regcoeff[[1]] <- updbe
covest <- list()
covest[[1]] <- updsig
@

\subsubsection*{First step of the SMCEM algorithm}
<<step1smcem, echo=TRUE>>=
res <- PbitEMstart(citygam, cityX, nc, nX, updbe, updsig, M)
loglike[1] <- res$loglike
### record sigma and beta at previous step for sequential sampling
prevBe <- updbe
prevSig <- updsig
### update sigma and beta with new estiamte
updbe <- res$estbe
updsig <- res$sigem
covest[[2]] <- updsig
regcoeff[[2]] <- updbe
@

\subsubsection*{Maximum likelihood estimation via SMCEM, loop}
<<smcLoopPars>>=
### parameters for kernel adaptation, sf defined in smcEM
log.fac <- 0 ### work on log to ensure scaling factor stays positive
alpha.wanted <- 0.3 ### target acceptance probability for control of adaptive MH
sf.ga <- 7 ### Stepsize to adapt the scaling factor
mh <- 4 ### number of mcmc steps within smc
@

<<mainLoop>>=
### sequential monte carlo EM ###
for (k in 2:nr){
	  res <- PbitEMloop(citygam, cityX, nc, nX, updbe, prevBe, updsig, prevSig, M)
		loglike[k] <- res$loglike
    ### record sigma and beta at previous step for sequential sampling
    prevBe <- updbe
    prevSig <- updsig
    updbe <- res$estbe ### update beta
    updsig <- res$sigem ### update sigma
		covest[[k+1]] <- updsig
    regcoeff[[k+1]] <- updbe
	}
simPbitRes <- list(loglike=loglike, estbe=updbe, estsig=updsig, regcoeff=regcoeff, covest=covest)     
@

<<saveSim, cache=FALSE>>=
if(tosave) save.image(file = savefile)
@

\subsection*{Maximum likelihood estimates}
<<parMLE, echo=FALSE, results='asis'>>=
print(paste("Obtained with ", M, " particles, and over ", nr, " iterations"))
betaMLE <- matrix(updbe, nrow=1)
betaMLE <- rbind(betaMLE,pbitcoeff)
dimnames(betaMLE) <- list(c("Beta", "Real beta"), paste0("beta", seq_along(updbe)-1))
xtable(betaMLE, caption="Maximum likelihood estimates of the regression coefficients and real values from which the data are simulated", digits=3)
sigmaMLE <- round(updsig,3)
sigmaMLE[lower.tri(sigmaMLE)] <- ""
dimnames(sigmaMLE) <- list(paste0("s", seq_along(sigmaMLE[,1])), paste0("s", seq_along(sigmaMLE[,1])))
xtable(sigmaMLE, caption="Maximum likelihood estimates of the correlation coefficients, matrix form", align=rep("r",length(sigmaMLE[1,])+1), digits=3)
realCov <- pbitcov
realCov[lower.tri(realCov)] <- ""
dimnames(realCov) <- list(paste0("s", seq_along(realCov[,1])), paste0("s", seq_along(realCov[,1])))
xtable(realCov, caption="Real covariance matrix from which the data are simulated", align=rep("r",length(realCov[1,])+1), digits=3)
@

\subsubsection*{Evaluate log-likelihood  and distance between real and estimated parameters}
<<loglikeplusdist>>=
peLogLike <- matrix(evallike(citygam, cityX, nc, updbe, updsig, refineM))
smcemFrob <- sqrt(
  sum((updsig[upper.tri(updsig, diag=TRUE)]-pbitcov[upper.tri(pbitcov, diag=TRUE)])^2)
  + sum((updbe-pbitcoeff)^2)
)
smcemFrobNorm <- smcemFrob/sqrt(length(updbe)+length((updsig[upper.tri(updsig, diag=TRUE)])))
peLogLike <- cbind(peLogLike, smcemFrobNorm)
@
<<showLoglike, echo=FALSE, results='asis'>>=
dimnames(peLogLike) <- list(NULL, c("log-likelihood", "distance"))
xtable(peLogLike, caption="Estimated log-likelihood value and square root of the mean squared distance of the estimated parameters from the real ones", digits=3)
@

\subsubsection*{Evaluate standard errors}
<<stderrors>>=
best <- matrix(0, nrow = nc, ncol = nobs)
for(i in 1:nobs) best[,i] <- cityX[[i]]%*%updbe

if(!constrained||useinvariance) 
  dimInf <- length(updbe)+nc*(nc+1)/2-1 else dimInf <- length(updbe)+nc*(nc-1)/2
totinfo <- matrix(0, nrow=dimInf, ncol=dimInf)
totHess <- matrix(0, nrow=dimInf, ncol=dimInf)
totestquad <- matrix(0, nrow=dimInf, ncol=dimInf)
totGradSq <- matrix(0, nrow=dimInf, ncol=dimInf)
totquval <- matrix(0, nrow=dimInf, ncol=dimInf)

for(j in 1:nobs){
  samp <- obseval(citygam[,j], best[,j], updsig, refineM)
  obsInfo <- fisher(updbe, updsig, cityX[[j]], samp$samp, samp$W)
  totquval <- totquval+obsInfo$quval ### total second moment expectation
  totGradSq <- totGradSq + obsInfo$gradsq ### total expectation of gradient quadratic form
  totestquad <- totestquad + obsInfo$quad ### total variance estimate
  totHess <- totHess + obsInfo$Hess ### total hessian estimate
  totinfo <- totinfo + obsInfo$info ###
}

myse <- sqrt(diag(solve(totinfo)))
@

<<displaySE, echo = FALSE, results = 'asis'>>=
myseSum <- data.matrix(t(summary(myse)))
xtable(myseSum, caption="Summary of the distribution of the standard errors of the estimated parmaters", digits=3)
@

